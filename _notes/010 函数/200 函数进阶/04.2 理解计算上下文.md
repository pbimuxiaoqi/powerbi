---
created: 2022-06-26
tags: 
- dax圣经 
- 上下文
subject: dax圣经
importance: 5
skilled: 4
status: 
author: sqlbi
url: 
cover: 
---

筛选上下文筛选，行上下文迭代。这意味着行上下文不筛选，筛选上下文不迭代。

## 在计算列使用SUM

第一个测试是在计算列中使用聚合函数。当下面的表达式用在 _Sales_ 表中的计算列时，结果如何？

```js
Sales[SumOfSalesQuantity] = SUM ( Sales[Quantity] ）
```

本质上，此公式等同于下面的写法：

```js
Sales[SumOfSalesQuantity] = SUMX ( Sales, Sales[Quantity]）
```

因为是计算列，将在行上下文中逐行计算。你认为下面三个选项哪个正确？

1.  _Quantity_ 所在行的值，每行的值不同。
2.  _Quantity_ 所有行的值合计， 所有行的值相同。
3.  错误；无法在计算列中使用 SUM。

公式的意思是“在当前的筛选上下文中，对所有可见行的数量求和。”另外，由于代码是在计算列中执行，DAX 在行上下文中对公式逐行计算。但是，行上下文并不会对表进行筛选。只有筛选上下文可以对表进行筛选。

到此，问题就转变为：当公式进行计算时，筛选上下文是什么？答案很直接：筛选上下文为空。筛选上下文通过可视化或查询创建。计算列是在数据刷新时进行计算，这时并没有筛选发生。所以，_SUMX_ 作用在整体 _Sales_ 表上聚合所有行 Sales[Quantity]的值。

正确的答案是第二个选项。计算列对每一行都计算相同的值，即 _Sales[Quantity]所有行的总计。_

![[Pasted image 20220626213346.png]]

这个例子说明两种计算上下文同时存在，但互不影响。两种计算上下文以不同的方式同时影响公式的结果。SUM，MIN，MAX 等聚合函数使用筛选上下文，忽视行上下文。牢记，筛选上下文筛选，行上下文迭代。

## 在度量值中使用列

第二个测试有些不同。思考利用度量值来创建计算毛利的公式，而不是在计算列中。现有净价格列产品成本列，编写如下公式：

```js
GrossMargin% := ( Sales[Net Price] - Sales[Unit Cost] ) / Sales[Unit Cost]
```

下面三个选项哪个是正确的？

1.  公式工作正常，需要在报表中验证结果。
2.  错误，无法编写公式。
3.  可以编写公式，但在报表中返回错误信息。

代码引用 *Sales[Net Price]*和 _Sales[Unit Cost]_ 但是没有使用任何聚合函数。DAX 需要获取两列中某一行的值。由于不存在迭代且公式并未位于计算列（行上下文）中，DAX 无法探测到公式需要哪一行参与计算。换句话说，DAX 缺少行上下文来获取两列中某一行的值来参与表达式的计算。记住，仅计算列存在自动的行上下文，度量值不存在。我们需要通过迭代在度量值中创建行上下文。

所以，正确的选项是第二个。无法编写公式。由于语法错误，当我们试图回车确认公式时，会显示错误信息。