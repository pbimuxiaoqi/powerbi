---
created: 2022-06-26
tags: 
- dax圣经 
- 上下文
subject: dax圣经
importance: 5
skilled: 4
status: 
author: sqlbi
url: 
cover: 
---
# 4.1 认识计算上下文

DAX 一共有三种计算上下文：
-   筛选上下文
-   行上下文
-   阴影筛选上下文 （一种特殊的上下文）

**筛选上下文筛选，行上下文迭代，他们并不相同**
计算上下文是 DAX 表达式在计算时所处的上下文环境。事实上，同一 DAX 表达式能够在不同的上下文环境中得出不同的值。

## 筛选上下文

所有的 DAX 表达式都是在上下文中进行计算的。上下文即为公式计算所处的“环境” 。

```js
Sales Amount:= SUMX ( Sales, Sales[Quantity] * Sales[Net Price] )
```

此公式计算 Sales 表中的 Sales[Quantity]与 Sales[Net Price]的乘积，然后求和。

![[Pasted image 20220626212635.png]]

这个公式准确地按照我们的要求来执行计算：销售额总计。在实际报表中，人们通常会利用某一列来分割此值。例如，将 _Brand_ 放入行中

![[Pasted image 20220626212653.png]]

销售额总计仍然显示在最底行，但现在它是各行的合计。然而，你应该注意到一个奇怪的现象：这个公式并没有按照我们的要求进行计算。事实上，在报表的每一个单元格内，这个公式并没有计算销售额总计。相反，它只计算指定品牌的销售额。最后，注意在代码中并没有指明它可以（或应该）计算数据的子集。筛选发生在公式外部。

因为 DAX 执行公式的计算上下文不同，每个单元格会计算出不同的值。你可以把一个公式的计算上下文想象成 DAX 在执行计算时所在报表单元格的周围区域。

**DAX** **的所有公式都是在各自的上下文环境中执行计算。即使是一样的代码，结果也会因为针对不同的数据子集而不同。**

这种上下文被称为筛选上下文。正如其名字所示，它用来筛选表。依赖于执行计算时的筛选上下文，任何公式在计算后都可能会产生不同的值。尽管这很容易理解，这其中隐藏了很多复杂的逻辑。

报表中的每个单元格都有不同的筛选上下文。你应该这样理解：在同一个报表中，每个单元格有各自不同的上下文——就如不同的语境——与其他单元格相互独立。计算引擎可能会在一定程度上通过内部优化来改善计算速度，但你应认为，DAX表达式对于每个单元格都有一个潜在的，相互独立的，自主作用的上下文。
因此上图中**总计行并非其他子行的合计**，而是 Sales表所有行的聚合计算。所以，即使在同一个报表中，合计行也可能会因DAX表达式的不同而显示与其他子行毫不相关的不同结果。

> **注** 为了表述简单，我们在前面的例子中使用了矩阵表格。我们也可以通过查询来定义计算上下文。你将会在后面的章节中详细了解。目前，以简单的报表形式更有助于我们在视觉上理解上下文的概念。

当 _Brand_ 位于行时，筛选上下文为每一个单元格筛选一个品牌。如果我们将年份放入列中以增加矩阵报表的复杂性

![[Pasted image 20220626212701.png]]

现在，每个单元格都显示某个品牌在某一年份的销售额，这是因为每个单元格的筛选上下文同时筛选了品牌和年份：行小计仅对品牌作筛选；而列小计仅对年份作筛选。总计单元格则因为筛选上下文并未对模型作任何筛选，所以计算所有销售的销售额。

对于矩阵报表的每一个单元格来说，参与交叉分析的列越多，筛选上下文就会对更多的列作筛选。如果将 _Store[Continent]_列加入行中，结果又将不同

![[Pasted image 20220626212709.png]]

现在，单元格的筛选上下文筛选了品牌，国家和年份。换句话说，筛选上下文包含了由报表中的行和列构成的全部字段集合。

> **注** 对于某个字段创建的筛选上下文，与其是否处于报表中的行或列，或是否位于切片器和/或页面/报表/可视化筛选，或任何由报表创建的筛选无关。所有这些筛选放在一起定义了一个筛选上下文由 DAX 用来计算公式。在行或列展示筛选对美化报表有所帮助，但不影响 DAX 结算结果。

Power BI 的可视化交互通过组合图表界面的不同元素构建筛选上下文。的确，单元格的筛选上下文由所有来自行，列，以及其他可视化筛选合并后计算得出。

![[Pasted image 20220626212715.png]]

上下文由包括切片，筛选，和其他可视化等多种方式定义。

对于左上角的单元格（A.Datum, CY 2007, 57,276.00)，其筛选上下文不仅筛选视图中的行和列，也筛选了来自不同可视化元素的 occupation (Professional)和 continent (Europe)。所有这些筛选决定了这个单元格单一的筛选上下文。DAX 引擎先于计算公式，先将筛选上下文应用于整个模型筛选出数据子集后再计算。

更正式的定义是，筛选上下文是多个筛选的集合。一个筛选是由一系列元组构成，一个元组是被定义的（多个）列值的集合。表 4-6 是指定单元格筛选上下文计算的视觉呈现。报表的每一个元素都参与创建筛选上下文。每个单元格都有不同的筛选上下文。

![[Pasted image 20220626212722.png]]

第一个筛选包含一个元组，值为 CY2007，来自 _Calendar Year_ 列。第二个筛选包含两个元组，来自 _Education_ 列，值分别为 High School 和 Partial College。第三个筛选包含一个元组，来自 _Brand_ 列，值为 Contoso。你可能注意到每个筛选包含的元组只来自单一列。你将会在后面学到如何创建来自多个列的元组。多列元组在 DAX 开发者手中是既强大又复杂的工具。

在最后，让我们回到本节最开始用到的度量值：

```js
Sales Amount := SUMX ( Sales, Sales[Quantity] * Sales[Net Price] )
```

正确阅读这个 DAX 公式的方式是：在当前的筛选上下文中，对 _Sales_ 表所有可见的行，先以 _Quantity_ 乘以 _Net Price_，然后对这些积求和。

对更简单的聚合计算同样实用。如下面所示的度量值：

```js
Total Quantity := SUM ( Sales[Quantity] )
```

它对 _Quantity_ 列在当前筛选上下文可见的所有行求和。你可以通过对应的 SUMX 版来更好的理解它是如何工作的：

```js
Total Quantity := SUMX ( Sales, Sales[Quantity] )
```

通过查看 [[SUMX]]的定义，我们可以认为筛选上下文影响 _Sales_ 表达式的计算，Sales 表达式只返回 _Sales_ 表中在当前筛选上下文可见的行。这样理解没错，但是你应该认为筛选上下文同样适用于如下度量值，尽管他们没有对应的迭代器：

```js
Customers := DISTINCTCOUNT ( Sales[CustomerKey] ) -- 在筛选上下文中对客户计数

Colors :=
VAR ListColors = DISTINCT ( 'Product'[Color] ) -- 筛选上下文中的不重复颜色
RETURN COUNTROWS ( ListColors ) -- 对不重复颜色计数
```

花费如此多的时间来强调筛选上下文且会影响公式计算结果这一概念似乎显得过于学术。实际上，DAX 的使用确实是需要极度精确的。多数 DAX 的复杂性并不在于学习新的函数，而是很多微妙的概念。当这些概念混合在一起就会产生复杂的情形。

## 行上下文

尽管行上下文和筛选上下文都是计算上下文，但二者却是不同的概念。正如前面小节中学到的，筛选上下文就如它的名字一样，目的是对表进行筛选。而**行上下文却不是用来筛选表**的，而是用来对表内容（也就是行）进行迭代并获取出其中的列值的。

这一次我们来定义一个计算列用来计算毛利润：

```js
Sales[Gross Margin] = Sales[Quantity] * ( Sales[Net Price] - Sales[Unit Cost] )
```


![[Pasted image 20220626212731.png]]

Gross Margin 列的每一行的值各不相同。

正如预料的，表中每一行在计算列的值都各不相同。因为公式中参与计算的三列在每一行都有不同的值，自然的，最终结果也会计算产生不同的值。与筛选上下文类似，这是因为某个计算上下文的存在。这一次，上下文环境没有筛选表，而是识别计算发生时所在的行。

> **注** 行上下文所引用的“行”指的是数据模型里的表中的行，与报表中眼睛看到的“行”不能混为一谈。DAX 不能直接引用报表中看到的行或列。Power BI 的矩阵或 Excel 的数据透视表所展示的值是 DAX 度量值在筛选上下文中计算的结果（记住这条更为重要），或者是数据模型的表本来就存储或通过计算列得出的值的自动聚合。

换句话说，我们知道一个计算列是逐行计算，但 DAX 是如何得知它正在迭代的是哪一行的？这是由另外一种计算上下文所规定的——_行上下文_。当我们在一张有100万行的表上创建一个计算列时，DAX创建了一个行上下文，使用行上下文作为光标来逐行迭代表并计算结果。

当我们创建一个计算列，DAX 默认自动创建行上下文，无需再手工创建：计算列的计算永远在行上下文中执行。你已经了解到如何手工创建行上下文——迭代。事实上，我们可以以度量值的形式编写毛利润，如下面的代码所示：

```js
Gross Margin :=
SUMX (
  Sales,
  Sales[Quantity] * ( Sales[Net Price] - Sales[Unit Cost] )
)
```

在此例中，由于是度量值，不存在自动的行上下文。_SUMX_ 作为迭代器，创建了一个行上下文开始逐行对 _Sales_ 表进行迭代。在迭代过程中，它在行上下文中执行 SUMX 的第二个表达式。所以，在迭代的每一步，DAX 引擎都知道应该使用表达式中三个列的哪个值。

行上下文存在于我们创建的计算列或迭代过程中的计算。不存在其他方式创建行上下文。另外，当我们需要获得某列某行的值时，需要利用行上下文。例如，下面的度量值是非法的。它试图计算 _Sales[NetPrice]_的值，但是由于行上下文的缺失使得计算时无法得知应采用哪一行。

```js
Gross Margin := Sales[Quantity] * ( Sales[Net Price] - Sales[Unit Cost] )
```

同样的表达式在计算列中执行是合法的，但在度量值中使用会变成不合法的。这并不是因为计算列和度量值有着不同的使用方法，而是因为计算列会自动创建行上下文，而度量值不会。如果想要在度量值中逐行计算该表达式，需要创建行上下文进行迭代。

> **注** 列引用需要行上下文来返回某个表的列值。列引用也可以用作某些不能自己创建行上下文的 DAX 函数的参数。例如 _DISTINCT_ 和 _DISTINCTCOUNT_ _就_可以直接使用列引用作为参数而不必定义行上下文。尽管如此，总的来说，DAX 表达式中的列引用需要计算行上下文。

行上下文并非是特殊的筛选上下文而用来筛选某一行。行上下文在任何情况下都不会筛选模型；行上下文仅仅对 DAX 做出指示应该使用表的哪一行。如果要筛选模型，筛选上下文才是正确的工具。换句话说，如果想要逐行计算表达式，行上下文才是正确的选择。