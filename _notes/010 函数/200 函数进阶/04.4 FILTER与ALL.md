---
created: 2022-06-26
tags: 
- dax圣经 
- 上下文
subject: dax圣经
importance: 5
skilled: 4
status: 
author: sqlbi
url: 
cover: 
---

想象一下，我们想要创建一个度量值用来计算产品颜色为红色的数量。 凭借迄今为止掌握的知识，公式很简单：

```js
NumOfRedProducts :=
VAR RedProducts =
    FILTER (
        'Product',
        'Product'[Color] = "Red"
    )
RETURN
    COUNTROWS ( RedProducts )
```

我们可以在报告中使用此公式。

![[Pasted image 20220626230420.png]]

_Brand_ 是表 _Product_ 的一列。 在报告的每个单元格内，筛选上下文筛选每一个给定的品牌。 因此，每个单元格显示给定品牌且颜色为红色的产品数量。因为 _FILTER_ 函数迭代 _Product_ 表，迭代的中间结果是当前筛选上下文中可见的值，即筛选上下文仅包括特定品牌的产品。

如果我们在筛选颜色的报告中添加切片器，这一点就更明显了。 在图 4-15 中，有两个相同的报告，使用两个切片器筛选产品颜色，每个切片器仅筛选其右边的报告。 左侧的报告筛选了产品颜色为 Red 其结果与图 4-14 中的相同，而右侧的报告是空的，因为切片器筛选了产品颜色为 Azure 的产品。

![[Pasted image 20220626230427.png]]

在右侧的报告中，_FILTER_ 迭代的 _Product_ 表仅包含产品颜色为 Azure 的产品，并且由于 _FILTER_ 只返回产品颜色为 Red 的产品，因此没有返回满足条件的产品。 因此，度量值 _NumOfRedProducts_ 的结果始终为空白。

这个例子的重要部分是，在同一个公式中，有一个筛选上下文来自外部 - 报告中的单元格，它受到切片器选择的影响 - 以及公式中由 _FILTER_ 函数引入的行上下文。 两个上下文同时起作用并影响计算结果。DAX 使用筛选上下文来计算 _Product_ 表的结果，并在 _F__**I**__LTER_ 函数引入的迭代环境中的行上下文中逐一计算筛选条件。

我们想再次重复这个概念：_**FILTER**_** 函数不会改变筛选上下文**。_FILTER_ 是一个迭代器，它扫描一个表（该表是被筛选上下文处理过的），并根据筛选条件返回该表的子集。

在图 4-14 中，筛选上下文筛选 Brand 列，并且在 _FILTER_ 返回结果后，它仍然只筛选了 Brand 列。在图 4-15 中我们添加了 Color 切片器，筛选上下文同时包含了 Brand 和 Color。 出于这个原因，在左侧报告中 _FILTER_ 函数返回所有迭代的产品，在右侧报告中它没有返回任何产品。 在两个报告中，_FILTER_ 都没有更改筛选上下文。_FILTER_ 仅扫描表并返回筛选结果。

此时，可能需要定义另一个公式，该公式返回红色产品的数量，而忽略在切片器上选择的值。 换句话说，代码需要忽略在切片器上选择的值，并且必须始终返回所有红色产品的数量。

为此，需要使用 _ALL_ 函数。_ALL 忽略筛选上下文_而返回所有表的内容。 我们可以创建一个名为 _NumOfAllRedProducts_ 的新度量，表达式的代码如下：

```js
NumOfAllRedProducts :=
VAR AllRedProducts =
    FILTER (
        ALL ( 'Product' ),
        'Product'[Color] = "Red"
    )
RETURN
    COUNTROWS ( AllRedProducts )
```

这次，_FILTER_ 不会迭代 _Prod__**u**__ct_。 而是迭代 ALL（Product）_。 ALL_ 忽略筛选上下文并始终返回表的所有行，即使产品先前已被品牌或颜色筛选，FILTER 依旧只返回红色产品。

图 4-16 中显示的结果 - 虽然正确 - 可能会令人惊讶。

![[Pasted image 20220626230437.png]]

这里有几个有趣的地方需要注意，我们想要更详细地描述它们：

-   无论在表格行上选择的 brand 如何，结果始终为 99。
-   左侧矩阵中的 brand 与右侧矩阵中的 brand 不同。

首先，99 是红色产品的总数，而不是任何给定品牌的红色产品的数量。_ALL_ - 按预期 - 忽略 _Product_ 表上的筛选。 它不仅忽略了 Color 上的筛选，而且还忽略了 Brand 上的筛选。 这可能是不希望的效果。 尽管如此，_ALL_ 函数简单而强大，但它的结果是全有或全无。 如果使用，则 _ALL_ 函数忽略参数表的所有筛选。 根据您迄今为止所获得的知识，您还不能选择仅忽略部分筛选。 在上述示例中，最好只忽略 Color 上的筛选。 只有在下一章之后，通过引入 CALCULATE 函数，您才能有更好的选择来实现选择性忽略筛选。

现在让我们来描述第二点：两份报告中的 Brand 不同。 因为切片器正在筛选一种颜色，所以矩阵使用针对颜色的筛选结果来计算结果。 在左侧颜色为 Red，而在右侧颜色为 Azure。 这决定了两组不同的产品，从而确定了品牌。 矩阵的 Brand 列使用针对 Color 列的筛选上下文得到结果。 一旦计算列值，DAX 就会计算度量值，无论 Brand 和 Color 如何，总是返回 99。 因此，左边的报告显示了 Red 产品的品牌，而右边的报告显示了 Azure 产品的品牌，尽管在两份报告中，无论其品牌如何，该度量值显示了所有红色产品的总数。